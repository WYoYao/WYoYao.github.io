---
layout:     post
title:      "JS 作用域"
subtitle:   "JS 作用域"
date:       2014-06-17
author:     "WYY"
header-img: "img/post-bg-js-version.jpg"
catalog: true
tags:
    - JavaScript
---



### 变量提升
> 在全局环境下的 var 和 function 声明的变量和函数都会进行变量提升，这个使用是var 声明的变量为undefined 通过function声明的函数已经声明和赋值可以直接调用，全局作用域下面不通过var 声明的变量(window的属性不进行变量提升直接调用的时候会报错)

```
// 不管条件会不会通过都会进行变量提升，但是不成立的时候不会进行赋值操作
if(false){
    if(false){
        var num=10;
    }
}
console.log(num);
```

```
// 在变量名冲突的时候不会重复的进行声明但是会进行重新赋值
console.log(fn);
var fn=10;
function fn() {
    console.log(123);
}
```

### 自执行函数
> 声明定义一起完成

```
// 自执行的函数在全局作用域下面不进行变量提升
(function () {})()
+function () {}
-function () {}
~function () {}
!function () {}
```

### 闭包
> 1.形成一个私有的作用域。  
> 2.如果有形参然后给形参赋值。  
> 3.进行私有作用域的预解释。  
> 4.函数中的方法从上到下依次执行。  
> 函数执行的时候形成一个私有作用域，保护私有作用域中的变量不受外界干扰，同时也不干扰外界变量，这样的机制称之为**闭包**。

### 作用域链
> **全局变量**在全局作用域下声明的为全局变量。
> **私有变量**如果是函数的形参和在函数内部被var 声明过，如果满足上面的一个就是私有变量。如果都二者都不满足的情况下，它就是全局变量。
>> 代码执行的过程中遇到一个变量，首先查找其是否为私有变量，如果不是私有变量则往私有作用域的上级查找，如果还找不到会一直向上级查找，一直找到window下面。**这个就是作用域链**。
>> 作用域链的查找与函数执行的位置无关，与函数声明定义的位置相关。

### 内存释放和作用域销毁
> **堆内存**如果是一个对象数据类型或函数数据类型的定义，都会开辟一个的堆内存，每个堆内存会有个引用的地址，如果这个地址被一个变量保存的时候，这个内存就会一直被占用，如果这个内存没有被任何一个变量引用的时候，过一段的时间这个变量会被释放。（浏览器会在空闲的时候将其释放。）
> **栈内存** 全局作用域和私有作用域使用的是栈内存，只有函数执行的时候是创建私有作用域，全局作用域只有的整个程序结束的时候才进行销毁，函数执行的时候创建一个私有的作用域，一般在整个私有作用域执行完成后，就进行销毁。（当前私有作用域的部分内容，如果被外界的东西引用，那么当前作用域就不能再进行销毁了。）
> 不会被销毁的几种情况
>- 1.返回一个引用类型的值。
>- 2.在外面被一个值所接收了。
```
function fn() {
    //返回引用类型的值
    return function () {}
}
//有值接受函数的返回值
var num =fn();
```

>- 1.在一个私有作用域中给一个DOM元素绑定事件，一般情况下私有的作用域都不销毁。

```
var odiv=document.getElementById('div');
//当这个函数执行完成了也不销毁
+function () {
    odiv.onclick=function () {}
}()
```

>- 下面的情况属于不立即销毁，fn 返回的方法没有被其他的类型所占用，但是还需要执行一次，所以暂时不进行销毁，当返回值执行完成之后，浏览器会在空闲的时候进行销毁。

```
function fn() { return function () {}}
//当下面的函数执行完成之后进行销毁
fn()()
```

### this关键字

> JS中的this代表是当前执行的主体，JS中的content代表的当前行为的执行环境。this跟在哪定义的和在哪执行的都没有关系，跟怎么执行的有关系。

> 辨识this的方法

>- 1.函数执行的时候，可以看下函数前面是否有点，如果有点，那个函数中的this就是'.'前面你的内容。如果没有'.'的时候，那个this 就是window

```
function fn() {
    console.log(this);
}
var obj={
    fn:fn,
}
obj.fn();
fn();
```

>- 自执行的函数中的this 永远是window.

```
+function () {
    console.log(this)
}()
```

>- 给一个DOM 绑定事件的时候，里面的this 指向的是当前这个DOM对象。


```js
var num=20;
var obj={
    num:30,//bnum
    fn:(function (num) {//20
        this.num*=3; // 2.NaN 当前的window的属性中并没有num的属性所以返回undefined 再执行*= 所以返回的NaN
        num+=15;//3.cnum=15
        var num=45;//cnum 4.cnum=45
        return function () {
            this.num*=4; //5.NaN 7.bnum=120
            num+=20;//  6.cnum=65 8.cnum=85
            console.log(num);
        }
    })(num)// 1全局变量中的num赋值给这个自执行函数  不是obj.num
}

var fn=obj.fn;
fn();//5.6. 65
obj.fn();// 7.8. 85
console.log(obj.num,num)
```

